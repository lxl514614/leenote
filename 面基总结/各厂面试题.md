# 各大厂面试题汇总

## 面试题

1. mysql事务隔离级别

   mysql有四个事务隔离级别

   - 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
   - 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
   - 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
   - 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞

   | 隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
   | :--------------------------- | :----------------- | :------------------------------- | :------------------- |
   | 未提交读（Read uncommitted） | 可能               | 可能                             | 可能                 |
   | 已提交读（Read committed）   | 不可能             | 可能                             | 可能                 |
   | 可重复读（Repeatable read）  | 不可能             | 不可能                           | 可能                 |
   | 可串行化（Serializable ）    | 不可能             | 不可能                           | 不可能               |

2. 什么是幻读? mysql是怎么解决幻读的?

   幻读:在一个事务里面, 多次查询之后, 查询的结果集条数不一致,而多或者少的行就叫做幻读

   mysql在RR的隔离级别下会产生幻读, mysql通过mvcc+next key用来解决幻读问题

   - 在快照读的情况下,通过mvcc来避免幻读

   - 在当前读的情况下,通过next-key来避免幻读

   https://mp.weixin.qq.com/s/Mq9UcV94mTxi6J5SwthV7g

3. mysql mvcc原理?

   什么是mvcc?

   全称Multi-Version Concurrency Control，即多版本并发控制。MVCC是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问，在编程语言中实现事务内存。

   它的实现原理主要是依赖记录中的 3个隐式字段，undo日志 ，Read View 来实现的.

   三个隐藏字段分别为:DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID

    DB_TRX_ID: 6byte，最近修改(修改/插入)事务ID：记录创建这条记录/最后一次修改该记录的事务ID

   DB_ROLL_PTR: 7byte，回滚指针，指向这条记录的上一个版本（存储于rollback segment里）

   DB_ROW_ID: 6byte，隐含的自增ID（隐藏主键），如果数据表没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引

   <img src="/Users/lee/Library/Application Support/typora-user-images/image-20210124141900263.png" alt="image-20210124141900263" style="zoom:50%;" />

   innodb 拥有一个自增的全局事务 ID，每当一个事务开启，在事务中都会记录当前事务的唯一 id，而全局事务 ID 会随着新事务的创建而增长

   同时，新事务创建时，事务系统会将当前未提交的所有事务 ID 组成的数组传递给这个新事务，本文的下面段落我们称这个数组为 TRX_ID 集合

   low_limit_id: 则记录了当前全局事务 ID + 1

   up_limit_id: 则记录了 trx_ids 中事务 ID 的最小值

   快照读:

   每当一个事务更新一条数据时，都会在写入对应 undo log 后将这行记录的隐藏字段 DB_TRX_ID 更新为当前事务的事务 ID，用来表明最新更新该数据的事务是该事务

   当另一个事务去 select 数据时，读到该行数据的 DB_TRX_ID 不为空并且 DB_TRX_ID 与当前事务的事务 ID 是不同的，这就说明这一行数据是另一个事务修改并提交的

   那么，这行数据究竟是在当前事务开启前提交的还是在当前事务开启后提交的呢？

   <img src="/Users/lee/Library/Application Support/typora-user-images/image-20210124143754121.png" alt="image-20210124143754121" style="zoom:50%;" />

   up_limit_id 记录了当前事务开启时所有未提交事务 ID 的最小值，他就是低水位线，而 low_limit_id 则记录了当前事务开启时全局事务 ID + 1，他就是高水位线

   如果某一行数据的 DB_TRX_ID 在 TRX_ID 集合中或大于等于 low_limit_id，那么就说明这行数据是在当前事务开启后提交的，如果某一行数据的 DB_TRX_ID 小于 up_limit_id 就说明该事务是当前事务开启前提交的

   对于当前事务开启后提交的数据，当前事务需要通过隐藏的 DB_ROLL_PTR 字段找到 undo log，然后进行逻辑上的回溯才能拿到事务开启时的原数据

   这个通过 undo log + 数据行获取到事务开启时的原始数据的过程就是“快照读”

   当前读:

   1. insert
   2. update
   3. select ... lock in share mode
   4. select ... for update

   https://techlog.cn/article/list/10183404#k

4. mysql索引什么情况下会失效?

   1. like查询%在前则不能走索引, 如: like '%xxx';
   2. 如果是组合索引的话, 需要满足最左匹配原则. 如 A,B,C三个字段, 直接查B或C不会命中索引
   3. 条件中有or, 如果条件的字段有不设置索引的则不会命中索引
   4. 索引无法存储null值，所以where的判断条件如果对字段进行了null值判断，将导致数据库放弃索引而进行全表查询
   5. where条件中尽量避免!= 或<> ,一级not in 和in要慎用, 容易导致全表扫描
   6. where条件字段如果使用函数或表达式操作,不会命中索引

5. Mysql 的数据存储结构

   MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm 文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。

   **.frm文件:**主要存放与表相关的数据信息,主要包括**表结构的定义信息** 

   **.ibd:**使用**独享表空间**存储**表数据和索引**信息，一张表对应一个ibd文件。 

   **ibdata文件:**使用**共享表空间**存储**表数据和索引**信息，所有表共同使用一个或者多个ibdata文 件。 

6. mysql b+树索引结构, 引申聚簇索引和非聚簇索引.

   B+树是左小右大的顺序存储结构，节点只包含id索引列，而叶子节点包含索引列和数据，这种数据和索引在一起存储的索引方式叫做聚簇索引，一张表只能有一个聚簇索引。假设没有定义主键，InnoDB会选择一个唯一的非空索引代替，如果没有的话则会隐式定义一个主键作为聚簇索引。

7. 为什么B+树比B树更适合做索引?

   B树也是多叉树结构，一种自平衡的树，而且B+树是从B树演化而来的，那么为什么不使用B+树的前身B树呢？从结构比较来看，B树相比B+树的一个主要区别就在于B树的分支节点上存储着数据，而B+树的分支节点只是叶子节点的索引而已。根据这个差别可以得出以下结论：

   - 磁盘IO读写次数相比B树降低了
       在B+树中，其非叶子的内部节点都变成了key值，因此其内部节点相对B 树更小。如果把所有同一内部节点的key存放在同一盘块中，那么盘块所能容纳的key数量也越多。一次性读内存中的需要查找的key值也就越多。相对来说IO读写次数也就降低了。
   - 每次查询的时间复杂度是固定的
       在B+树中，由于分支节点只是叶子节点的索引，所以对于任意关键字的查找都必须从根节点走到分支节点，所有关键字查询路径长度相同，每次查询的时间复杂度是固定的。但是在B树中，其分支节点上也保存有数据，对于每一个数据的查询所走的路径长度是不一样的，所以查询效率也不一样。
   - 遍历效率更高
       由于B+树的数据都存储在叶子节点上，分支节点均为索引，方便扫库，只需扫一遍叶子即可。但是B树在分支节点上都保存着数据，要找到具体的顺序数据，需要执行一次中序遍历来查找。所以B+树更加适合范围查询的情况，在解决磁盘IO性能的同时解决了B树元素遍历效率低下的问题。

8. mysql 索引覆盖原理

   覆盖索引就是在一次查询中, 在索引上的数据就满足了查询所需的字段值,这时便不需要再次回表进行一次主键查询.这种情况称之为索引覆盖.比如我们的索引创建字段是"age, name", 那么此时"select name from t where age = 10", 该查询便不会再次回表.就如果我们查字典, 通过目录就知道我们要查询的内容了, 就不用再次翻到内容信息的具体页面了.

9. mysql的锁机制

   Mysql中锁的分类按照不同类型的划分可以分成不同的锁，按照**「锁的粒度」**划分可以分成：**「表锁、页锁、行锁」**；按照**「使用的方式」**划分可以分为：**「共享锁」**和**「排它锁」**；按照思想的划分：**「乐观锁」**和**「悲观锁」**。

   mysql锁分为共享锁,和排他锁.也叫做读锁和写锁

   读锁是共享的, 可以通过lock in share mode实现，这时候只能读不能写。

   写锁是独占的,它会阻塞其他的写锁和读锁。从颗粒度来区分，可以分为**表锁**和**行锁**两种。

   表锁会锁定整张表并且阻塞其他用户对该表的所有读写操作，比如alter修改表结构的时候会锁表。

   行锁又可以分为**乐观锁**和**悲观锁**，悲观锁可以通过for update实现，乐观锁则通过版本号实现。

10. mysql主从复制机制

    1. master服务器将数据改变的记录写进二进制binlog日志, 当master数据改变时,则将其变化写进biglog日志
    2. slave机器会在一定时间间隔内对master二进制日志进行探测其是否发生改变,如果发生改变则开始一个I/O thread线程请求master二进制事件
    3. 同时主节点为每个I/O线程启动一个dump线程,用于向其发送二进制事件,并保存至从节点本地的中继日志中.从节点将启动sql线程从中继日志中取出二进制日志.在本地做重放.使其数据和主节点保持一致.最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

    也就是说:

    从库会产生两个线程, 一个I/O线程, 一个SQL线程

    I/O线程会去请求主节点的binlog日志,并将得到的binlog数据写到本地的rely-log(中继日志)中.

    主库会生成一个log dump的线程用来给从库I/O线程传binlog

    SQL线程会读取中继日志中的日志,并解析成sql逐一执行.

11. mysql中一个字段设置varchar(256)和varchar(10)有什么区别?

    varchar是变长字段类型,相同长度字符串, 两者存储占用磁盘空间是一样的.

    虽然存储占用的磁盘空间一样, 但是消耗的内存不一样,更长的列消耗的内存会更多.因为mysql通常会分配固定大小的内存块来保存内部值,尤其是使用临时表进行排序操作时,会消耗更多的内存,使用磁盘排序也一样.

12. mysl中大表加字段或索引怎么操作?

    1. 临时表方式.先创建一张临时的新表, 复制当旧表结构.再将旧表数据写入到新表.写入完成后删除旧表. 再将新表重命名

       其中过程需要注意, 复制数据的过程是比较耗时的过程,期间可能有新的数据写入.所以一次复制完成后最好根据创建时间再次进行确认,是否有增量数据, 再将增量数据做好同步,防止丢数据

    2. 使用pt-online-schema-change工具进行添加

13. mysql的innodb和myisam有什么区别?

    innodb支持行锁, myisam不支持

    innodb支持外键, myisam不支持

    innodb支持事务,myisam不支持

    innodb使用mvcc机制,myisam没有

    innodb5.7之前不支持全文索引, myisam支持全文索引

    selectcount(*)上面myisam更快,存储引擎做了计数缓存

14. mysql对字符串很长的字段加索引怎么设计?

    1. 直接创建索引, 该种方式会占用大量的存储空间,自然是不满足优化策略的
    2. 使用前缀索引,例如类似于email这类的字段,字符串后部分都是相同的, 可以考虑只对前缀部分做索引, 不过需要权衡好前缀的长度
    3. hash索引,将对应字段hash之后作为索引存储，hash之后冲突的概率较低，也可大大降低回表的次数。只是由于需要存储字段hash之后的数据，会增加额外存储空间的占用。

15. redis集群模式原理

16. redis哨兵模式原理

17. redis中的数据结构

18. zset的数据结构

19. redis在项目中都做什么用?

20. redis持久化机制有哪些?

21. redis怎么保证高可用?

22. redis事务机制了解吗?

23. 服务中redis挂了怎么办?

24. spring 的bean是线程安全的吗?

25. spring是怎么解决循环依赖问题的?

26. spring的事务传播机制?

27. mybatis的一级缓存和二级缓存都存储的是什么?

28. kafka怎么保证消息不丢失?

29. kafka有事务吗?

30. kafka支持延时队列吗?

31. kafka的ISR和AR是什么意思?

32. kafka怎么保证消息只被消费一次?

33. java中HashMap和CurrentHashMap原理及底层实现

34. synchronized的实现机制

35. synchronized加在一个类的静态方法和普通方法上 会互斥吗?

36. synchronized加在一个类的两个静态方法上会互斥吗?

37. synchronized的锁优化机制了解吗?

38. synchronized和ReentrantLock的区别?

39. ReentranLock的实现原理?

40. AQS原理?

41. HashMap和CurrentHashMap底层实现原理? 1.7和1.8

42. java线程池底层实现原理?

43. classloader热加载机制实现原理?

44. 指令重排序了解吗?

45. jvm的内存结构?

46. 什么情况下会发生OOM? 

47. 垃圾回收器了解吗? CMS的原理和G1的原理描述下?

48. G1是怎么定位可回收的垃圾的?

49. new对象的过程?

50. 知道双亲委派模型吗? 为什么要用双亲委派模型

51. 有哪些垃圾回收算法?

52. volatile原理了解吗?

53. ThreadLocal的实现原理? 

54. ThreadLocal会有什么问题?

55. tomcat的结构了解吗?

## 算法题

1. 两数之和
2. 爬楼梯
3. 实现一个栈
4. 两个字符串相加
5. 田忌赛马