一面
（因为过程比较顺利，题目没有好好记下来，大概就是下面这些吧）

1.项目相关
2.hashmap
3.线程a 等b,b等c的实现
4.类的equals重写
5.线程安全是什么 如何保证多线程安全

http://www.jasongj.com/java/thread_safe/

### 什么是线程安全

《Java并发编程实践》中对线程安全的定义：

> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象就是线程安全的。

《深入理解Java虚拟机》的作者也认可这个观点。本人也认为这是一个恰当的定义，因为线程安全的主体是什么？是方法还是代码块？这里给出的主体是对象，这是非常恰当的，因为Java是纯面向对象的，Java中一切为对象。因此通过对象定义线程安全是恰当的。

但是，这里并不是说其他的方式定义不对（这里绝没有这个意思）。我们可以看一下其他的定义方式，进行一下对比：

> 当多个线程访问某个方法时，不管你通过怎样的调用方式或者说这些线程如何交替的执行，我们在主程序中不需要去做任何的同步，这个类的结果行为都是我们设想的正确行为，那么我们就可以说这个类时线程安全的。
> 如果一段代码可以保证多个线程访问的时候正确操作共享数据，那么它是线程安全的

### 多线程编程中的三个核心概念

- 原子性

> 这一点，跟数据库事务的原子性概念差不多，即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
>
> 关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。

- 可见性

> 可见性是指，当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。可见性问题是好多人忽略
> 或者理解错误的一点。
>
> CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。
>
> 这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。

- 有序性

> 顺序性指的是，程序执行的顺序按照代码的先后顺序执行。
>
> 以下面这段代码为例
>
> ```
> boolean started = false; // 语句1    
> long counter = 0L; // 语句2    
> counter = 1; // 语句3    
> started = true; // 语句4 
> ```
>
> 从代码顺序上看，上面四条语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。
>
> 处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。
>
> 讲到这里，有人要着急了——什么，CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，大家大可放心，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。

### 如何实现线程安全

- 第一种 : 互斥同步

> 何谓同步？在多线程编程中，同步就是一个线程进入监视器（可以认为是一个只允许一个线程进入的盒子），其他线程必须等待，直到那个线程退出监视器为止。
>
> 在实现互斥同步的方式中，最常使用的就是Synchronized 关键字。
>
> synchronized实现同步的基础就是：Java中的每一个对象都可以作为锁。
>
> 具体表现为：

> ```
> 1.普通同步方法，锁是当前实例对象
> 2.静态同步方法，锁是当前类的Class对象
> 3.同步方法块，锁是Synchronized括号里匹配的对象
> ```

- 如何实现？

  - synchronized经过编译之后，会在同步块的前后生成 monitorenter 和monitorexit这两个字节码指令。这两个字节码指令之后有一个reference类型（存在于java虚拟机栈的局部变量表中，可以根据reference数据，来操作堆上的具体对象）的参数来指明要锁定和解锁的对象。根据虚拟机规范，在执行monitorenter 指令时，首先会尝试获取对象的锁，如果该对象没有被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加一。若获取对象失败，那当前线程就要阻塞等待，直到对象锁被另一个线程释放。
  - synchronized用的锁是存放在对象头里面的，在jdk1.6之后，锁一共有四种状态：无锁状态，偏向锁状态（在对象头和栈帧中的锁记录里存储偏向锁的线程id），轻量级锁状态（将对象头的mark word复制到当前线程的栈帧的锁记录中，使用CAS操作将对象头中的markWord指向栈帧中的锁记录，如果成功，则线程就拥有了对象的锁。如果两个以上的线程争用一把锁的话，则膨胀为重量级锁），重量级锁状态。

  因为之前我一直都很迷惑，所以我接下来讲一讲这一方面 ：

  大家应该都知道，java 在虚拟机中除了线程计数器，java虚拟机栈 是线程私有的，其余的java堆，方法区，和运行时常量池都是线程共享的内存区域。java堆是存储对象和数组的，但是对象在内存中的存储布局可以分为三块区域：对象头，实例数据（对象真正存储的有效信息，程序代码中所定义的各个类型的字段内容），对齐填充。

  为什么说synchronized的锁是存放在对象头里面呢？因为对象头里面也存储了两部分信息：第一部分呢，存储对象自身的运行时数据，包括哈希码，GC分代年龄，锁状态标识位，线程持有的锁，偏向锁Id，偏向时间戳等数据。第二部分是类型指针，虚拟机通过这个来确定该对象是哪个类的实例。

  如何判断该对象有没有被锁？对象头里面锁状态的标志位会发生变化，当其他线程查看synchronized 锁定的对象时，会查看该对象的对象头的标志位有没有发生变化，若标志位为01，则表示未锁定，为00时，则表示轻量级锁定，为10时，则为重量级锁定状态。为01时，则为偏向锁，为11时，则为GC标记状态。

除了synchronized 关键字之外，还可以使用JUC包下的重入锁来实现同步 。

- 第二种方法就是：非阻塞同步

  因为使用synchronized的时候，只能有一个线程可以获取对象的锁，其他线程就会进入阻塞状态，阻塞状态就会引起线程的挂起和唤醒，会带来很大的性能问题，所以就出现了非阻塞同步的实现方法。

  ```
    先进行操作，如果没有其他线程争用共享数据，那么操作就成功了，如果共享数据有争用，就采取补偿措施（不断地重试）。
    
    我们想想哈，互斥同步里实现了 操作的原子性(这个操作没有被中断) 和 可见性（对数据进行更改后，会立马写入到内存中，其他线程在使用到这个数据时，会获取到最新的数据），那怎么才能不用同步来实现原子性和可见性呢？ 
    
    CAS是实现非阻塞同步的计算机指令，它有三个操作数：内存位置，旧的预期值，新值，在执行CAS操作时，当且仅当内存地址的值符合旧的预期值的时候，才会用新值来更新内存地址的值，否则就不执行更新。
    
       使用方法：使用JUC包下的整数原子类decompareAndSet（）和getAndIncrement（）方法
    
    缺点 ：ABA 问题  版本号来解决
    
    只能保证一个变量的原子操作，解决办法：使用AtomicReference类来保证对象之间的原子性。可以把多个变量放在一个对象里。
  ```

- 第三种：无同步方案

  线程本地存储：将共享数据的可见范围限制在一个线程中。这样无需同步也能保证线程之间不出现数据争用问题。

  经常使用的就是ThreadLocal类

  ThreadLocal类 最常见的ThreadLocal使用场景为 用来解决数据库连接、Session管理等。

  ```
    public T get() { }  
    public void set(T value) { }  
    public void remove() { }  
    protected T initialValue() { }  
       
  get()方法是用来获取ThreadLocal在当前线程中保存的变量副本，set()用来设置当前线程中变量的副本，remove()用来移除当前线程中变量的副本，initialValue()是一个protected方法，一般是用来在使用时进行重写的，它是一个延迟加载方法
  ```

  其实引起线程不安全最根本的原因 就是 ：线程对于共享数据的更改会引起程序结果错误。线程安全的解决策略就是：保护共享数据在多线程的情况下，保持正确的取值。

6.public private protected

https://blog.csdn.net/spu20134823091/article/details/53836192

7.简单工厂 抽象工厂 是什么

https://blog.csdn.net/jerry11112/article/details/80618420

8.判断一个数组是不是后序遍历（代码 ）

二面
（二面一开始的时候我还是有些紧张的，但是我没想到居然挺简单，这也直接导致我三面轻敌了）

1.项目（10min）

2.算法题：判断一个字符串是否是一个IPV4
3.算法题：连续子数组的最大和(剑指Offer上的题)
4.Java异常体系（运行时与非运行时异常的区别）

**1.Java异常机制**

Java把异常当做对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类。Java中的异常分为两大类：错误Error和异常Exception，Java异常体系结构如下图所示：

![img](https://img-blog.csdn.net/20140825105709593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVodWlfY3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

图片来源：http://blog.csdn.net/wuwenxiang91322/article/details/10346337



**2.Throwable**

Throwable类是所有异常或错误的超类，它有两个子类：Error和Exception，分别表示错误和异常。其中异常Exception分为运行时异常(RuntimeException)和非运行时异常，也称之为不检查异常(Unchecked Exception)和检查异常(Checked Exception)。



**3.Error**

一般是指java虚拟机相关的问题，如系统崩溃、虚拟机出错误、动态链接失败等，这种错误无法恢复或不可能捕获，将导致应用程序中断，通常应用程序无法处理这些错误，因此应用程序不应该捕获Error对象，也无须在其throws子句中声明该方法抛出任何Error或其子类。



**4.可查异常和不可查异常**

通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）。
可查异常（编译器要求必须处置的异常）：正确的程序在运行中，很容易出现的、情理可容的异常状况。可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。
除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。
不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。

如果使用throw在方法体中抛出可查异常，则需要在方法头部声明方法可能抛出的异常类型。程序会在throw语句后立即终止，它后面的语句执行不到，然后在包含它的所有try块中（可能在上层调用函数中）从里向外寻找含有与其匹配的catch子句的try块。



**5.运行时异常和非运行时异常**

(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。

当出现RuntimeException的时候，我们可以不处理。当出现这样的异常时，总是由虚拟机接管。比如：我们从来没有人去处理过NullPointerException异常，它就是运行时异常，并且这种异常还是最常见的异常之一。 
出现运行时异常后，如果没有捕获处理这个异常（即没有catch），系统会把异常一直往上层抛，一直到最上层，如果是多线程就由Thread.run()抛出，如果是单线程就被main()抛出。抛出之后，如果是线程，这个线程也就退出了。如果是主程序抛出的异常，那么这整个程序也就退出了。运行时异常是Exception的子类，也有一般异常的特点，是可以被catch块处理的。只不过往往我们不对他处理罢了。也就是说，你如果不对运行时异常进行处理，那么出现运行时异常之后，要么是线程中止，要么是主程序终止。 
如果不想终止，则必须捕获所有的运行时异常，决不让这个处理线程退出。队列里面出现异常数据了，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响下面对正常数据的处理。


(2)非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。如IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。



**6.finally关键字**

来看看下面这个test1()方法：



```java
public int test1() {
		try {
			return 1;
		} finally {
			return 2;
		}
	}
```

方法test1将返回2；



怎么解释呢？再来看看下面这个test2()方法：



```java
public int test2() {
		int i = 1;
		try {
			System.out.println("try语句块中");
			return 1;
		} finally {
			System.out.println("finally语句块中");
			return 2;
		}
	}
```

运行结果是：



try语句块中
finally语句块中
2

从运行结果中可以发现，try中的return语句调用的函数先于finally中调用的函数执行，也就是说return语句先执行，finally语句后执行，所以，返回的结果是2。return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。

5.HashCode与equals的区别

https://blog.csdn.net/fmwind/article/details/76460733

6.JVM内存区域划分（程序计数器，虚拟机栈，本地方法栈，堆，方法区，运行时常量池）
7.JVM内存回收方法（判断对象是否已死<1面那个问题>，新生代老年代的垃圾回收算法
8.哪些对象可以作为GC Roots
9.数据库中delete和drop的区别
10.数据库事务的使用场景
11.数据库三大范式
12.数据库索引的创建原则
13.数据库索引底层实现（B+树）
14.线程，进程，程序的区别
15.死锁的产生条件
16.继承与***模式的优劣势
三面
1.项目
2.三次握手四次挥手
3.TCP核心机制（滑动窗口，快速重传机制，拥塞控制...可以参考我以前的博客）
4.HTTP和HTTPS及其区别
5.若建立连接时间比较长，HTTP是怎么优化的（注意是HTTP不是TCP）
（ 网络怼到我哑口无言，问了三个问题都答不上来，这才换了一个方面，也是从这里我开始慌了）
6.接着问了我【性能优化的相关问题】（我答不上来，后面就又问了性能优化的方面的其他，我还是说不会）
7.性能优化完全答不上之后又问了音视频开发。大致就是为什么编码，常见的音视频格式，ffmpeg，opengl，egl，android怎么往ndk通信与调用的



1.倒排索引

2.讲讲redis里面的哈希表？

3.happen-before的规则？

4.volatile修饰符，synchronize锁

5.java单例模式的实现，懒汉、饿汉？

6.进程与线程的区别，多进程和多线程的区别？

7.HashMap原理，为什么用红黑树，红黑树的特点？

8.快排时间空间复杂度，最好最坏的情况，优化方案？

9.TCP的拥塞控制，具体过程是怎么样的？UDP有拥塞控制吗？如何解决？

10.讲讲了解的垃圾回收算法和回收器，什么时候执行STOP THE WORLD？

11.了解Go语言吗？


五、头条二面（大数据+项目）
1.Kylin的项目架构

2.Paxos和ZAB协议

3.CAP理论，分区容错性的意义

4.大表Join小表优化，如何处理数据倾斜？

5. 讲一下最大堆和最小堆

6.HDFS的读取、写入，容错处理。（源码）

7.MapReduce的过程（第一版和第二版的）

8.MR shuffle，Spark shuffle。

9.namenode HA，脑裂，Yarn的调度机制。

10. Hive的内部表和外部表区别、数仓建模模型、数仓分层、雪花模型和星型模型。

11.了解ClickHouse吗？它与Kylin的区别？

六、头条三面（算法+场景题）
1.LRU算法实现（伪代码）

2.链表倒数第K个数（讲思路）

3.一堆螺丝和螺母用最短时间匹配（代码实现）

4.求每天浏览页面的新用户（Hive QL实现）

5.求抖音小视频每日点击量最高的10个（Hash + 最小堆）
